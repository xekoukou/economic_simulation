<!DOCTYPE html>
<html>
<head>
<title>Economic Simulation</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="d3.min.js"></script>
<script src="Markdown.Converter.js"></script>
<script src="Markdown.Extra.js"></script>
<script src="sigma.min.js"></script>
<script src="markdown.js"></script>
<script src="sigma.layout.forceAtlas2.min.js"></script>
<script src="jquery-2.1.4.min.js"></script>
<script src="chart.js"></script>
<script src="simulate.js"></script>
<link rel="stylesheet" href="highlight/styles/default.css">
<script src="highlight/highlight.pack.js"></script>
<script src="MathJax-master/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="markdown.js"></script>
<link rel="stylesheet" href="pure-min.css">
<link rel="stylesheet" href="markdown.css">
<link rel="stylesheet" href="chart.css">
<script src="simple_barter.js"></script>
</head>
<body>
    <div style="top:0px; left:0px; position:fixed; z-index: 10000;" >
    <button class="pure-button pure-button-primary" onClick='simulation.start()'>start</button>
    <button class="pure-button pure-button-primary" onClick='simulation.continue()'>continue</button>
    <button class="pure-button pure-button-primary" onClick='simulation.stop()'>stop</button>
    <button class="pure-button pure-button-primary" onClick='simulation.reset()'>reset</button>
    </div>
    <div style = "font-size:120%">
       <div class="markdown">
_

# Simple Robinson Model


This model consists of a single person. He lives alone in the wilderness. He has to build his own tools and catch his own meal. There is no money. There is no trade. There is no cooperation. How can we model the economy of a single person? 

We need to model the choices that robisnson makes with regard to the labor he puts and the products he creates. 
Does he save goods for the winter? Does he make tools? Any attempt to do that would require us to model the person Robinson. 
But there is no theory we can use to simulate the human person's choices nor his change of habits due to external factors.
What we will do is use a simple model about the person and then try to prove that any other model of the person would have the same results.
In order to allow other models to replace our model, we will have a specific api that all models would need to implement. Each model will have to decide on which choices the person takes.

We will assume that a person has specific wants that are common among all people like food, clothing etc. and whose value do not change very much. There are also wants that are specific to each person and whose value can change a lot or not depending on the person. Of course, we have to take the assumption that the wants do not change based on previous experiences.
In other words, the fact that you didn't eat food yesterday doesn't make you hungrier today. Whether that invalidates our results is an interesting question to find.

Similarly, we will assume that the person cannot predict what he will want in the future. He can only project his wants of today into the future. Thus that person will not undertand that when he gets very old, he would need to have someone to take care of him. Of course, in Robinson's case, that is not possible.

These wants determine the choices of Robinson.

* if \\[W_{a} < W_{b}\\] then R chooses b.
* if \\[W_{a} + W_{b} > W_{c}\\] then R chooses a.

In order to simulate this, we will use the Gaussian distribution.
$$ f : R \rightarrow R $$
$$f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{\frac{-(x-\mu)^{2}}{2\sigma^{2}}}$$

```javascript

function Guassian(sigma_, median_) {
  this.sigma = sigma_;
  this.median = median_;
  this.const = 1/(sigma * Math.sqrt(2 * Mapth.PI));
  this.exp_const = -1/(2 * sigma * sigma);

  this.at = function(x) {
    return this.const * Math.exp(this.exp_const * (x - this.median) * (x - this.median));
  }

  this.max = this.at(0);
}
```

We will not generate each person with the same wants. We will randomly generate wants but the median will follow the guassian distribution. From a technical point of view, robinson will not know he wants something until he finds it.

```javascript

Person.prototype.new_want = function(id,gaussian) {
  this.wants[id] = gaussian.at(id) * Math.rand();
}

```

The change of preferences will be simulated by this function. The magnitude constant gives us the choice to determine the global magnitude of change of preferences.

```javascript

Person.prototype.change_wants = function(magnitude,gaussian) {
  Object.keys(this.wants).forEach(function(id){
    this.wants[id] += magnitude * (2 * Math.rand() - 1) * (guassian.max - (gaussian.at(id))/guassian.max);
  });
}

```

At the same time that a person has specific wants, he also has a preference in types of work. We generate this the same way we generated the wants but this time we do not have a gaussian distribution, only a uniform distribution. (A task can be either production or research.)

```javascript
Person.prototype.new_task_preference = function(id) {
  this.task_preferences[id] = Math.rand();
}
```

```javascript
Person.prototype.change_task_preferences = function(magnitude) {
  Object.keys(this.task_preferences).forEach(function(id){
    this.task_preferences[id] += magnitude * (2 * Math.rand() - 1);
  });
}
```

We wouldn't have wants if there weren't products that fulfilled those wants. If there weren't, then we would simulate futility rather than the economy.

A product thus fulfills specific wants. We specify the percentage of fulfillment that a product provides to a specific want. 1 or 100% means that it has been completely fulfilled.

In order to generate the fulfilled_wants randomly, we need to know the maximum number of wants that our system will have.

```javascript
var max_wants = 1000;
var max_product_wants = 5;

function Product(id,max_wants, max_product_wants, magnitude){
  this.fulfilled_wants = {};

  var number_of_wants = Math.floor(Math.random() * 5 + 1);
  for(var i = 0; i < number_of_wants; i++) {
    while(true) {
      var id = Math.random() * 1000;
      if (!(id in this.fulfilled_wants)){
        this.fulfilled_wants[id] = magnitude * Math.random();
        break;
      }
    }
  }
}
```

A product certainly doesn't exist unless you pick it or create it. Thus there is a production process that might require tools to perform or not. How can we model production?

## Production process

There is one fundamental property of production. Humans create tools to help them in the production process.
 We will discuss the research process in the next section but we need 
to use that property so as to model the production process.
Thus first of all, production exists that doesn't create human goods but tools.
 Secondly production itself has as inputs both tools and human labor/materials.

Materials can be either raw ones extracted from nature or parts produced in other production plants.
Thus another property is that the production process can be split into multiple ones in which only the last one assemples the final product.

The production process can be defined as a function that takes the above as input and generate a specific product at a specific volume.

\\[P:TxLxM \rightarrow P\\]
\\This function is informal. Fix it TODO.

The main problem for defining a general production process is that the sum of 
its parts does not determine the  whole production process. The way that the process 
is performed cannot be deduced by the people that take part or the tools.
 We could add the organization structure as a factor of productivity.
 Since we cannot meaususe or specify in a general manner the interelations 
of the workers and their effect on productivitym we will have to do the
 above simplicication. In order to account for that simplification,
 we will introduce a productivity multiplication factor that will 
be generated with a gaussian distribution of small varriance for
 every group of workers on a specific production process.

Having introduced the above multiplier we can now model the production process as the weighted sum of the productivity of the working force mutiplied by the tool that is used.

Let us note that we can consider that each tool identifies uniquely a specific production process.
Other tools will be used for different production processes. The only exception is when a tool is an improvement of another tool. Then they share the production process, they only have a different multiplier.

A tool can be used for either production or for research purposes. We will define the research process in following sections. A tool obtains its properties during research.

```javascript
function Tool() {
  this.id;
//for research or production
  this.type;
  this.multiplier;
  this.process;
}
```

Each person also needs to define its productivity with regard to a specific production process.
Here again we use a uniform distribution. In general when a person learns of a new task/production_process, it imediatelly knows both its preference to it as well as his productivity, thus our introduction of a helper function.

```javascript
Person.prototype.new_task_productivity = function(task_id,number_of_different_positions) {
  var multi = [];
  for( var i = 0; i < number_of_different_positions; i++) {
    multi.push(Math.rand);
  }
  this.new_task_productivities[task_id] = multi;
}

Person.prototype.new_task = function(task_id,number_of_different_positions) {
  this.new_task_preference(task_id);
  this.new_task_productivity(task_id,number_of_different_positions);
}
```

\\TODO We have used a uniform distribution. In the next chapter, we will introduce a function that determines the similarity of different knowledge units. This could allow us to determine productivity based on the productivy on similar tasks.

Now we are ready to define the production process. We define the output out of a single day of production.

```javascript
Production_process.prototype.output(workers,tool) {
  var result = 0;
  var self = this;
  self.position_weights.forEach(function(weight,index) {
    for(var i = 0; i < self.number_of_workers_in_position[index]; i++) {
      result += weight * workers[index][i].task_productivities[self.id][index];
    }
  });
  return tool.multiplier * (result/self.weights_sum);
}

function Production_process() {
  this.id;
  this.position_weights = [];
  this.number_of_workers_in_position = [];
  this.weights_sum;
  this.product_type;
  this.product_id;

 //Here we need to generate the above values. we need to look at research to do so. 

}
```

How do the production processes emerge? Research.
Thus one would have to model **research**. 

## Research

Research and knowledge is one of the fundamental property of human society. It distinguishes us from other animals. We have the ability to learn new methods and build new tools that helps us in the production of goods necessary for our survival. Thus there can be no model of an economy without incorporating the process of research in it.

In order to model research, we need to abstract the process of research. We will not know the content of the research. But the content of the research plays an important role in the economy. Let us have an example. A bakery has a bread recipe. If it researchs new knowledge based on the bread recipe, it should be almost impossible to find a way to manufacture bicycles. Why do we have to avoid this in our abstract model? Because then we loose one important characteristic of knowledge/research that influences the economy. Economic agents that have relevant knowledge are much more likey to learn new related knowledge.

Thus we need to abstractly identify the relative similarity of different knowledges. By quanitifying the similarity of knowledge we can then provide a formula that describes the similarity of products produced by those researches.

The second property of research is that the more knowledge one receives on a certain topic, the more difficult it is to learn new things. This will allow us to provide a formula that determines the probability that a new research will succeed or not.

At the same time, it is not only the previous knowledge the only factor that determine research. Research tools are also required. Tools are randomly generated but the probability of creating a new tool is relatively very low compared to improving an existing tool. In other words, tool creation for research is determined by the same rules like any other product.

Let us put those ideas into a more formal language.

* A unit of knowledge \\(K\\) depends on a set of previous knowledge units \\(dep_{K}=\\{i=1..n|K_{i}\\}\\).
We say that \\(K\\) depends on \\(K_{i}\\) for its research and we write \\[K_{i} \xrightarrow{dep} K \\].
* We say that \\(K_{a}\\) is an ancestor of \\(K\\) if there is a directed path from \\(K_{a}\\) to \\(K\\) in the graph of Knowledge dependencies.

Research is performed in 2 ways.

1. It is performed either for the improvement or specialization of a specific knowledge unit.

In this case, the only dependency is the specific knowledge unit.

* We say that the new knowledge is a specialization of the previous knowledge and we write \\[K_{c} \xrightarrow{spec} K  \\].
* We say that the new knowledge is an improvement of the previous knowledge and we write \\[K_{i} \xrightarrow{impr} K  \\].

2. Research is performed on a number of dinstict fields so as to create a new field.

* We say that the new knowledge is derived from multiple knowledges and is a new dinstinct field, we write \\[K_{i} \xrightarrow{sum} K  \\].

//Check The more similar those knowledge fields are , the more probable it is to produce new knowledge.

### Research types and the effect on the new production processes and their products.

The relation of the production processes and products that the new knowledge introduces depends on the type of research performed. For impovement of previous knowledge, the products fulfill similar needs as the knowledge they depend on.

For specialization or summing of knowledge(s) there is no relation to the fulfilled needs of the new products with those of the ancestor knowledge(s). The production processes though have similarities since they are similar technologies. Thus there is a relation of the productivity of the workers on the new production processes with the olds ones.

Thus from an economic point of view, one would specialize on the field of research with the higher porbability or because the working force has good productivity on this production sector. The same applies for summing different knowledges.

//Clean or remove this. We have already pointed about it before. (similarity of distinct knowledges, is this true by the way?)
It is important to view the creation of a distinct field of knowledge from multiple ones in this context. As an effort to increase the probability of success. There should be though a multiplying factor in this case. Certainly picking random fields of knowledge and trying to mix them should have less probability due to that randomness.


Now that we have defined the graph of knowledge dependencies and types of knowledge expansion, we can use the properties of this abstract graph to define the probability of a research succeeding as well as its results.


The relevant code follows:

```javascript
function Knowledge() {
  this.id;
  this.type;
//many only when we sum different knowledges.
  this.knowledge_dependencies = {};
  this.tool_dependencies = {};
  this.new_production_processes = {};
//the production processes contain the information about which products this technology enables.
}

Research_process.prototype.output(workers,tools) {
  var result = 0;
  var self = this;
  self.position_weights.forEach(function(weight,index) {
    for(var i = 0; i < self.number_of_workers_in_position[index]; i++) {
      result += weight * workers[index][i].task_productivities[self.id][index];
    }
  });
  return tool.multiplier * (result/self.weights_sum);
}

function Research_process() {
  this.id;
  this.position_weights = [];
  this.number_of_workers_in_position = [];
  this.weights_sum;
  this.product_type;
  this.product_id;

 //Here we need to generate the above values. we need to look at research to do so. 

}

function research_impr(ancestor, dependencies, tools) {
  
}
```



Now that we have defined the graph of knowledge dependencies and types of knowledge expansion, we can use the properties of this abstract graph to define the probability of a research succeeding as well as its results.

-------

At the same time, an improvement on previous knowledge can lead to improvements on the dependent knowledges.

* Each knowledge has a probability of producing new knowledge that depends on its position in the graph of knowledge dependencies. 

* There can be no relation between the tools needed and the knowledge dependencies except from the fact that of tools were usefull to research some knowledge they will still be usefull for improved knowledge.
Other than that, the knowledge required to build a tool is independent of its research use. But in order to build a new tool out of some random knowledge for a specific research is very very low.
This is also true for products.

* Creating a dist field is more probable if dependent multiple knowledges have more similarity.

Therd are 2 cases. The improvement is on the technology we are researching or on a more fundamental theory that this research depends on.
There are 2 cases. Development of a product or of a technology.

Research has 2 processes. First, we merge dinstict knowledge sectors to create a product or a new knowledege sector. Secondly, we use the knowledge of previous merges as a research accelerator.

We witness 2 important processes in real life. 
Previous knowledge can accelerate the research of a similar but better product. Research at the same time can lead to unexpected results that create new products that are not related to the previous ones.
It is certain that previous knowledge accelerates research in both cases. What would be the dependencies of the new knowledge on the previous knowledge? Are there multiple research paths on the improvement of the same product with the same previous knowledge?

We model knowledge this way. Any previous knowledge can lead to new knowledge but the difficulty of getting new knowledge increases as we extract new knowledge. That is consistent with reality. It can explain why patents block other enterprises from researching similar things. Also, as we learn new things, our new knowledge doesn't give us a lower probability to learn new things. New knowledge is more difficult to learn.

```
function Production_process(id) {
this.id;
}
```

```javascript

function Person {
  this.wants = {};

}
```









       </div>
    </div>
</body>
</html>
